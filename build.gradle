/*
 * This file was generated by the Gradle 'init' task.
 *
 * This is a general purpose Gradle build.
 * Learn more about Gradle by exploring our samples at https://docs.gradle.org/8.0/samples
 */

plugins {
    //подключение Java плагина
    //теперь можно выполнить команду gradle tasks и посмотреть все доступные таски
    //далее можно попробовать выполнить gradle build и посмотреть ациклическое дерево все тасок
    id 'java'

    //подключаем плагин war, чтобы собирать war файлы
    id 'war'

}

java {
    sourceCompatibility = JavaVersion.VERSION_17
    targetCompatibility = JavaVersion.VERSION_17
}

repositories {
    mavenCentral()
}

configurations {
    Configuration configurationImpl = getByName("implementation")

    customConfiguration {
        description = "custom configuration"
    }
    configurationImpl.extendsFrom(customConfiguration)

    //чтобы переопределить стратегию выбора версии пересекающихся зависимостей
    //нужно это явно указать в нужной конфигурации , либо во всех конфигурациях
    //all { resolutionStrategy { force('.........') } }
    all {
        resolutionStrategy {
            force('org.springframework:spring-web:6.0.0')
        }
    }

}

dependencies {
    // 1й способ добавить зависимости
    /*add("implementation",[group:  "org.junit.jupiter", name: "junit-jupiter", version: "5.9.2"])
    add("implementation",[group:  "org.springframework", name: "spring-webmvc", version: "6.0.6"])*/

    //2й способ добавить зависимости
    /*    add("implementation","org.junit.jupiter:junit-jupiter:5.9.2")
    add("implementation", 'org.springframework:spring-webmvc:6.0.6')*/

    //3й способ добавить зависимости
    customConfiguration 'org.springframework:spring-webmvc:6.0.6'
    implementation 'org.springframework:spring-aop:6.0.6'
    testImplementation 'org.junit.jupiter:junit-jupiter:5.9.2'

    //исключаем транзитивную зависимость org.slf4j:slf4j-api из spring-data-jpa
    implementation('org.springframework.data:spring-data-jpa:3.0.3') {
        exclude(group: 'org.slf4j', module: 'slf4j-api')
    }

    //исключаем все транзитивные зависимости из spring-boot-test
    implementation('org.springframework.boot:spring-boot-test:3.0.4') {
        transitive(false)
    }

    //по умолчанию если явно подтянуть зависимость, которая уже есть в транзитивных зависимостях,
    //то по умолчанию Gradle будет брать зависимость с более высокой версией
    implementation 'org.springframework:spring-orm:6.0.0'
    implementation 'org.springframework:spring-web:6.0.0'

    //чтобы переопределить стратегию выбора версии пересекающихся зависимостей
    //нужно в нужной Configuration сделать вызов {Configuration}.version.strictly({version}) и указать нужную версию
    implementation('org.springframework:spring-tx') {
        version {
            strictly '6.0.0'
        }
    }

    //чтобы обеспечить совместимость различных зависимостей,
    //можно внедрить зависимость целой платформы, в которой уже определены совместимые версии зависимостей.
    //например org.springframework.boot:spring-boot-dependencies
    implementation platform('org.springframework.cloud:spring-cloud-commons-dependencies:4.0.1')

    //теперь нет необходимости определять версии зависимостей. Т.к. они входят в зависимость внедренную выше,
    //то и версии этих зависимостей будут браться оттуда же
    implementation 'org.springframework.cloud:spring-cloud-commons'

}

sourceSets {
    main {
        java {
            srcDir "$buildDir/generated-sources/mapstruct"
        }
    }

}

//через блок ext можно добавлять настройки (properties) gradle
ext {
    javaVersion = 17
}

println ""

//способы получения gradle properties
println javaVersion
println ext.javaVersion
println project.ext.javaVersion
println project.javaVersion

println ""

println "Configuration phase"
println "Gradle hash code: ${gradle.hashCode()}"
println "Project hash code: ${rootProject.hashCode()}"

//task("hello")

//1
/*
def helloTask = tasks.findByName("hello")
helloTask.group = "custom group"
helloTask.description = "This is the Hello task"
*/

//2
/*
hello.group = "custom group"
hello.description = "This is the Hello task"
*/

//3
/*
hello {
    println "Configuration phase. Hello task"
    group = "custom group"
    description = "This is the Hello task"
}
*/

//4
/*
task hello {
    println "Configuration phase. Hello task"
    group = "custom group"
    description = "This is the Hello task"
}
*/

//5
task hello(group: "custom group", description: "This is the Hello task") {
    doLast {
        println "Second action"
    }
    doFirst {
        println "First action"
    }
    doLast {
        println "Third action"
    }
    println "Configuration phase. Hello task"
    println "Group: $group, description: $description, number of actions: $actions.size()"
    println "Task path: $path"
}

task firstTask {
    doLast {
        println "First task"
    }
}

task thirdTask {
    doLast {
        println "Third task"
    }
}

task secondTask {
    dependsOn(firstTask)
    finalizedBy(thirdTask)
    doLast {
        println "Second task"
    }
}

task forthTask {
    dependsOn(secondTask)
    doLast {
        println "Forth task"
    }
}

gradle.taskGraph.whenReady { TaskExecutionGraph graph ->
    println "----- Graph: "
    graph.allTasks.each {
        println "${it.name}"
    }
}

task seventhTask {
    doLast {
        println "Seventh task"
    }
}
task sixthTask {
    mustRunAfter(seventhTask)
    doLast {
        println "Sixth task"
    }
}
task fivethTask {
    mustRunAfter(sixthTask)
    doLast {
        println "Fiveth task"
    }
}
task eighthTask {
    group = "custom group"
    dependsOn([fivethTask, sixthTask, seventhTask])
    doLast {
        println "Eighth task"
    }
}

//noinspection GrDeprecatedAPIUsage
gradle.taskGraph.beforeTask { Task task ->
    if (task.group == "custom group") {
        println "Before task callback"
    }
}

//noinspection GrDeprecatedAPIUsage
gradle.taskGraph.afterTask { Task task ->
    if (task.group == "custom group") {
        println "After task callback"
    }
}

//Используем таску из скрипта
apply from: 'myscript.gradle'

//Плагин
class MyPlugin implements Plugin<Project> {

    @Override
    void apply(Project target) {
        def map = [description: "plugin tasks", group: "plugin tasks"]

        target.task(map, "plugintask") {
            doLast {
                println "run plugin task"
            }
        }
    }
}

//Используем таску из плагина
apply plugin: MyPlugin

//определяем формирование jar файла
jar {
    //указываем путь до главного исполняемого файла
    manifest {

        def jarsPaths = configurations.runtimeClasspath.files.collect { "lib/$it.name" }
        attributes 'Main-Class': 'com.gradle.example.HelloWorld',
                'Class-Path': jarsPaths.join(" ")
    }

    //1й способ сформировать fat jar со всеми распакованными зависимостями
    /*//игнорируем дубликаты файлов в разных jar
    duplicatesStrategy(DuplicatesStrategy.EXCLUDE)

    //добавляем распакованные зависимости в jar
    from(configurations.runtimeClasspath.files.collect { zipTree(it) })*/
}

//2й способ сформировать jar без зависимостей. Все зависимости кладем в папку $buildDir/libs/lib
task copyAllDependencies(type: Copy) {
    from(configurations.runtimeClasspath.files)
    into("$buildDir/libs/lib")
}
//и делаем таску jar зависимой от нашей таски
jar.dependsOn copyAllDependencies


//установка общих настроек для всех проектов
allprojects {
    //устанавливаем один репозиторий для всех проектов
    //теперь из других build.gradle файлов можно удалить установку репозитория
    repositories {
        mavenCentral()
    }
}